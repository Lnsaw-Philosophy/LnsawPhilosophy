# 指令体（InstructionStruct）

**InstructionStruct** 是 Lnsaw Api 的核心载体，代表了一种结构化的交互范式。本文档旨在阐述其设计理念。

为直观展示其结构，下文以 JSON 格式为例。**请注意，这仅是一种表示形式，并非限定 InstructionStruct 必须为 JSON 对象**，它可以是任何满足此数据模型的序列化格式。

**InstructionStruct** 是一种通用的通信单元模型，可应用于 Lnsaw API、RPC、gRPC 等多种交互场景。它本质上是一个**承载“Instruction”的实体**，其关系如同物质承载声波，或光子承载能量。

>如需获取完整的 JSON Schema 定义，请参阅 [InstructionStruct.json]。

## 特性
**InstructionStruct** 原生支持多种特性，例如：批量请求、全链路追踪、指令回放。

## InstructionStruct 的结构

**InstructionStruct** 的诞生基于现实与指令思想，其命名未采用技术术语，而是借鉴了现实中“信件”的场景，以追求更直观的认知。

### 主结构
**InstructionStruct** 主要由三部分构成：
+ 1、**指令标识**：包含三个ID，用于全链路追踪（详见后文）。
+ 2、**发信 (dispatch)**：替代传统的Request，描述了指令的发出方、意图和内容。
+ 3、**回信 (reply)**：替代传统的Response，描述了指令的处理结果。
``` JSON
{
  "globalId": "DateTime.Utc +_+ GUID",
  "parentId": null,
  "selfId": "DateTime.Utc +_+ GUID",
  "dispatch": {},
  "reply": {},
}
```
### 发信 (dispatch)
`dispatch` 类比于信件，由信封 (`envelope`) 和信文 (`letter`) 两部分组成。

#### 信封 (envelope)

`envelope` 包含了指令的元数据，为指令的整个生命周期提供上下文。无论是系统基础设施（如网关、审计）用于路由和追踪，还是最终的收件人（业务服务）用于预处理和业务分发，都需要依赖此部分信息。 这使得各方无需深度解析业务内容（letter）即可完成各自职责。

+ **postedAt**：指令的发送时间，通常由发起指令的代理（如浏览器、HTTP客户端）自动生成。
+ **letterType**：指令的类型。此字段主要供各级基础设施（如网关、负载均衡器、审计系统）使用，用于快速判断指令的核心意图。
  + **DO**：**执行**，一个通用类型，表示希望接收方执行一个动作或流程。当其他类型不适用时，可使用此类型。
  + **GET**：**获取**，表示“我需要你为我提供某物”。为明确获取范围，可细分为：
    + **GET-F (Full)**:期望获取一个完整的实体。
      >"请将档案柜中的‘张三’档案袋，拿给我看看"
    + **GET-P (Partial)**:期望只获取实体的部分信息。
      >"请将档案柜中的‘张三’档案袋的个人信息页，拿给我看看。档案袋中的其他部分不用拿给我。"
  + **PUT**: **给予**，表示“我给你一个实体/实体的一部分”。为精确表达意图，可细分为：
    + **PUT-C (Create)**: 期望**创建**一个新实体。仅当目标不存在时执行操作。
      >“我将一份员工‘张三’的档案袋交给你，请你放入档案柜。如果柜子里已经有一个‘张三’的档案袋，什么也不用做。”
    + **PUT-U (Update)**: 期望**更新**一个已存在的实体。仅当目标存在时执行操作。
      >“我将一份员工‘张三’的档案袋交给你，请你替换掉档案柜中的‘张三’档案袋。如果柜子没有‘张三的档案袋’，什么也不用做。”
    + **PUT-S (Set)**: 期望确保某个实体存在，并且其内容与指令所描述的完全一致。
      >“我将一份员工‘张三’的档案袋交给你，请你确保档案柜中‘张三’的档案就是我给你这份。如果之前没有，就把这份放进去；如果之前有，就把旧的拿出来，把这份新的放进去。”
    + **PUT-X (Patch)**: 期望**修改**实体的**一部分**。此操作可用于更新或删除（置空）某个部分。
      >“我将一页属于一份‘张三’档案袋的个人信息页给你，请你替换掉档案柜中‘张三’档案袋里的旧的个人信息页。如果柜子里根本没有‘张三’的档案，什么也不用做。

      >“请将档案柜中‘张三’档案袋中的个人信息页拿出来扔掉，如果柜子里根本没有‘张三’的档案，什么也不用做。
  + **DEL**: **丢弃**，表示“此物我不要了，你可以将其丢弃”。此操作针对整个实体。
      >“档案柜里的‘张三’档案袋不需要了，请你把整个档案袋从档案柜中移除并销毁。”
+ **sender**：**发件人**。表明是哪个 Actor 发送了此指令。（关于 Actor 的详细定义，请参阅 Lnsaw Actor 文档）。
  + **actorType**：**Actor 类型**。表明发件主体的类别，例如：NaturalPerson（自然人）、LegalPerson（法人）、Bot（机器人）。
  + **actor**：**Actor的标识**。发件主体的唯一标识。其值根据认证状态和方式而定：
    >**匿名请求**："actor": "anonymity",
    >**通过 Token 认证**："token:A35D8X3E5A8CX3XD5F8A3GS8",
    >**通过 JWT 认证**："JWT:fxcgaeff65F89GR5df21f5e==", 
  + **agent**：**代理者**，指最终实际发出此指令的 Actor（通常是一个 Bot）。例如，自然人用户通过浏览器访问系统，真正的发信者是浏览器这个 Bot。
    >"bot:browser_chrome_edge" 
    >"bot:actorcenter.lnsaw.com:443,botId:2358sef35c8sfe2sa6f85" 
+ **receiver**：**收件人**。表明此指令的预期接收者。
  + **endpoint**：**接收端点**。收件人的网络地址，用于物理路由。
    >"https://actorcenter.lnsaw.com:443"
  + **route**：**路由路径**。一个路径数组，用于指定应用内部的具体处理节点。此字段是实现批量请求等高级路由策略的关键依据。
    >["/api/auth"]
  + **actor**:**目标Actor**。除了使用路径抽象，也可直接指定一个或多个具体的 Bot Actor 作为接收者。其路由逻辑与 `route` 数组类似，为实现更精细的指令分发提供了可能。
    >["bot:auth_service_v1"]
    >["bot:gateway_asia_1", "bot:gateway_eu_1"]
  + **【重要约束】**：`actor` 与 `route` 数组在指令中互斥，不可同时使用。 此约束确保了在批量请求等场景下，指令能够被清晰、准确地路由。
+ **intent**：**业务意图**，一个意图数组，用于声明指令需要达成的业务目标。**此字段与 receiver 协同工作，是实现批量请求和复杂业务流的核心。** 其内容可根据业务需求高度自定义，为系统提供了极大的表达灵活性。
  >["NaturalPerson.Login"]
  >["NaturalPerson.Login","NaturalPerson.Info"]
  >["Order.Place.Prepare","Inventory.Lock","Payment.Create"]


#### 信文 (letter)

`letter` 承载指令的具体业务参数，其角色类似于传统 RESTful 架构中的 Request Body。此字段被设计为数组格式，旨在与 `receiver`（收件人）、`intent`（业务意图）协同工作，共同构成实现批量请求的最终环节。

+ `receiver` 指定了“在哪里处理”（目标节点）。
+ `intent` 指定了“要做什么”（业务目标）。
+ `letter` 指定了“用什么做”（操作参数）。

#### json 结构
```json
"dispatch": {
    "envelope": {
      "postedAt": "2025-11-21T10:40:00.000Z",
      "letterType": "DO",
      "sender": {
        "actorType": "NaturalPerson",
        "actor": "anonymity",
        "agent": "bot:browser_chrome_edge"
      },
      "receiver": {
        "endpoint": "https://actorcenter.lnsaw.com:443",
        "route": [
          "/api/auth"
        ]
      },
      "intent": [
        "NaturalPerson.Login"
      ]
    },
    "letter": [
      {
        "username": "zhangsan",
        "password": "encrypted_hash"
      }
    ]
  },
```



### 回信 (reply)




# 特性

## 批量请求
### 规范和模式
为实现批量请求，指令的构造需遵循以下规则与模式。
#### 基本原则
+ **单一性**：一次批量指令只能包含一种 letterType。
+ **一致性**：一次批量指令只能指向一个 receiver.endpoint。
+ **互斥性**：receiver 中的 actor 与 route 数组不可混用。
#### 支持的模式
根据 `receiver.actor/receiver.route	`、`intent`、`letter` 三个数组长度的不同组合，可实现多种批量请求模式。
|**模式**|receiver.actor/receiver.route|intent|letter|说明|
|-|-|-|-|-|
|**多目标，多任务**|`N`个|`N`个|`N`个|将 N 个不同的任务分发给 N 个不同的目标。|
|**单目标，多任务**|`1`个|`N`个|`N`个|将 N 个不同的任务发送给 1 个目标处理。|
|**单目标，单任务，多参数**|`1`个|`1`个|`N`个|将 1 个任务的 N 份参数发送给 1 个目标处理。|
|**单目标，单任务，单参数**|`1`个|`1`个|`1`个|标准单次请求。|

#### 执行策略
实现层应提供可配置的策略机制，以支持对批量指令采用不同的执行方式。

例如，对于单目标、单任务、多参数的指令，可根据策略配置决定：

+ 并行执行：将多个参数分配给多个控制器实例同时处理，以提高吞吐量。
+ 串行执行：在前一个参数处理完成后，再开始下一个参数的处理，以保证顺序性或减少资源争用。

具体的配置与实现方式（如通过拦截器、注解、配置文件等）由各语言或框架的适配库自行决定。
### 价值与优势
## 全链路追踪
## 指令回放